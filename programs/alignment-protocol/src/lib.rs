use anchor_lang::prelude::*;

declare_id!("BMYn8rtstaZhzFZtgMVMY9io1zhnqacr3yANZrgkv7DF");

// Module declarations
pub mod data;
pub mod error;
pub mod helpers;
pub mod contexts;
pub mod instructions;

// Re-export important data structures for clients
pub use data::*;
#[allow(unused_imports)]
pub use error::*;

// Import what's needed for the program module
use contexts::*;

// Expose client code generated by Anchor
pub mod __client_accounts_contexts {
    pub use super::contexts::*;
}

#[program]
pub mod alignment_protocol {
    use super::*;

    /// Instruction handler: initialize the protocol with four token mints
    pub fn initialize(ctx: Context<Initialize>) -> Result<()> {
        instructions::initialize::initialize(ctx)
    }

    /// Instruction handler: update the number of tokens to mint for each submission
    pub fn update_tokens_to_mint(
        ctx: Context<UpdateTokensToMint>,
        new_tokens_to_mint: u64,
    ) -> Result<()> {
        instructions::initialize::update_tokens_to_mint(ctx, new_tokens_to_mint)
    }

    /// Instruction handler: explicitly create user's ATA
    ///
    /// This does NOT use `init_if_needed`. Instead, it does a CPI to the associated_token::create method.
    /// If the ATA already exists, this transaction will fail (unless you do extra checks).
    pub fn create_user_ata(ctx: Context<CreateUserAta>) -> Result<()> {
        instructions::tokens::create_user_ata(ctx)
    }

    /// Instruction handler: Create a user profile for tracking reputation
    ///
    /// This creates a new PDA account to store the user's reputation metrics
    pub fn create_user_profile(ctx: Context<CreateUserProfile>) -> Result<()> {
        instructions::topics::create_user_profile(ctx)
    }

    /// Instruction handler: Create a new topic
    ///
    /// This creates a new topic that submissions can be added to.
    /// Only the protocol authority can create topics.
    pub fn create_topic(
        ctx: Context<CreateTopic>,
        name: String,
        description: String,
        commit_phase_duration: Option<u64>,
        reveal_phase_duration: Option<u64>,
    ) -> Result<()> {
        instructions::topics::create_topic(
            ctx,
            name,
            description,
            commit_phase_duration,
            reveal_phase_duration,
        )
    }

    /// Instruction handler: Submit data to a specific topic
    ///
    /// This creates a submission and links it to a topic, setting up the voting phases.
    pub fn submit_data_to_topic(
        ctx: Context<SubmitDataToTopic>,
        data_reference: String,
    ) -> Result<()> {
        instructions::submission::submit_data_to_topic(ctx, data_reference)
    }

    /// Instruction handler: Stake temporary alignment tokens to get temporary reputation tokens
    ///
    /// Burns tempAlign tokens and mints an equal amount of tempRep tokens
    pub fn stake_alignment_tokens(
        ctx: Context<StakeAlignmentTokens>,
        amount: u64,
    ) -> Result<()> {
        instructions::tokens::stake_alignment_tokens(ctx, amount)
    }
    
    /// Instruction handler: Stake topic-specific temporary alignment tokens
    ///
    /// Burns tempAlign tokens from a specific topic and mints tempRep tokens for that topic
    pub fn stake_topic_specific_tokens(
        ctx: Context<StakeTopicSpecificTokens>,
        amount: u64,
    ) -> Result<()> {
        instructions::tokens::stake_topic_specific_tokens(ctx, amount)
    }

    /// Instruction handler: Submit data directly on-chain
    /// 1) Creates new `Submission` account with the given data.
    /// 2) Mints a fixed number of temporary alignment tokens to the user's ATA.
    /// 3) Increments the state's submission_count.
    pub fn submit_data(ctx: Context<SubmitData>, data_reference: String) -> Result<()> {
        instructions::submission::submit_data(ctx, data_reference)
    }

    /// Instruction handler: Commit a vote on a submission within a topic
    ///
    /// This creates a vote commitment without revealing the actual vote choice.
    /// The actual vote is hashed with a nonce for privacy during the commit phase.
    pub fn commit_vote(
        ctx: Context<CommitVote>,
        vote_hash: [u8; 32],
        vote_amount: u64,
        is_permanent_rep: bool,
    ) -> Result<()> {
        instructions::votes::commit_vote(ctx, vote_hash, vote_amount, is_permanent_rep)
    }

    /// Instruction handler: Reveal a previously committed vote
    ///
    /// This reveals the actual vote choice and verifies it matches the previously committed hash.
    /// If valid, it adds the voter's voting power to the appropriate yes/no counter.
    pub fn reveal_vote(
        ctx: Context<RevealVote>,
        vote_choice: VoteChoice,
        nonce: String,
    ) -> Result<()> {
        instructions::votes::reveal_vote(ctx, vote_choice, nonce)
    }

    /// Instruction handler: Finalize a submission within a topic after voting
    ///
    /// This determines if a submission is accepted or rejected based on voting results.
    /// For accepted submissions, it converts contributor's tempAlign tokens to permanent Align tokens.
    pub fn finalize_submission(ctx: Context<FinalizeSubmission>) -> Result<()> {
        instructions::submission::finalize_submission(ctx)
    }

    /// Instruction handler: Finalize a validator's vote after submission has been finalized
    ///
    /// This processes the token rewards or penalties for a validator based on their vote:
    /// - For correct votes: Burn tempRep tokens and mint permanent Rep tokens
    /// - For incorrect votes: Just burn tempRep tokens with no replacement
    /// - No penalty for permanent Rep tokens used for voting
    pub fn finalize_vote(ctx: Context<FinalizeVote>) -> Result<()> {
        instructions::votes::finalize_vote(ctx)
    }

    /// Instruction handler: Link an existing submission to a topic
    ///
    /// This creates a new SubmissionTopicLink for an existing Submission and Topic,
    /// allowing the submission to be voted on in multiple topics independently.
    /// Anyone can link if they are willing to pay the transaction fee.
    pub fn link_submission_to_topic(ctx: Context<LinkSubmissionToTopic>) -> Result<()> {
        instructions::submission::link_submission_to_topic(ctx)
    }
}
