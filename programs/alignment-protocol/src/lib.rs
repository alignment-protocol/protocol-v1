use anchor_lang::prelude::*;

declare_id!("3NYwpp7xv6m35he2sbWTDKPyzepwQiJq5YkD2AzdHmRc");

// Module declarations
pub mod contexts;
pub mod data;
pub mod error;
pub mod helpers;
pub mod instructions;

// Re-export important data structures for clients
pub use data::*;
#[allow(unused_imports)]
pub use error::*;

// Import what's needed for the program module
// Removed legacy contexts
use contexts::*;

// Expose client code generated by Anchor
pub mod __client_accounts_contexts {
    pub use super::contexts::*;
}

#[program]
pub mod alignment_protocol {
    use super::*;

    /// Instruction handler: initialize the protocol state (Part 1)
    pub fn initialize_state(ctx: Context<InitializeState>) -> Result<()> {
        instructions::initialize::initialize_state(ctx)
    }

    /// Instruction handler: initialize temp_align_mint (Part 2a)
    pub fn initialize_temp_align_mint(ctx: Context<InitializeTempAlignMint>) -> Result<()> {
        instructions::initialize::initialize_temp_align_mint(ctx)
    }

    /// Instruction handler: initialize align_mint (Part 2b)
    pub fn initialize_align_mint(ctx: Context<InitializeAlignMint>) -> Result<()> {
        instructions::initialize::initialize_align_mint(ctx)
    }

    /// Instruction handler: initialize temp_rep_mint (Part 2c)
    pub fn initialize_temp_rep_mint(ctx: Context<InitializeTempRepMint>) -> Result<()> {
        instructions::initialize::initialize_temp_rep_mint(ctx)
    }

    /// Instruction handler: initialize rep_mint (Part 2d)
    pub fn initialize_rep_mint(ctx: Context<InitializeRepMint>) -> Result<()> {
        instructions::initialize::initialize_rep_mint(ctx)
    }

    /// Instruction handler: update the number of tokens to mint for each submission
    pub fn update_tokens_to_mint(
        ctx: Context<UpdateTokensToMint>,
        new_tokens_to_mint: u64,
    ) -> Result<()> {
        instructions::initialize::update_tokens_to_mint(ctx, new_tokens_to_mint)
    }

    /// Instruction handler: explicitly create user's ATA for permanent tokens (Align, Rep)
    ///
    /// This does NOT use `init_if_needed`. Instead, it does a CPI to the associated_token::create method.
    /// If the ATA already exists, this transaction will fail (unless you do extra checks).
    pub fn create_user_ata(ctx: Context<CreateUserAta>) -> Result<()> {
        instructions::tokens::create_user_ata(ctx)
    }
    
    /// Instruction handler: create protocol-owned temporary token account for a user
    ///
    /// This creates a token account for temporary tokens (tempAlign, tempRep) that is
    /// owned by the protocol (state PDA) rather than the user, allowing the protocol
    /// to burn tokens without requiring user signatures.
    pub fn create_user_temp_token_account(ctx: Context<CreateUserTempTokenAccount>) -> Result<()> {
        instructions::tokens::create_user_temp_token_account(ctx)
    }

    /// Instruction handler: Create a user profile for tracking reputation
    ///
    /// This creates a new PDA account to store the user's reputation metrics
    pub fn create_user_profile(ctx: Context<CreateUserProfile>) -> Result<()> {
        instructions::topics::create_user_profile(ctx)
    }

    /// Instruction handler: Create a new topic
    ///
    /// This creates a new topic that submissions can be added to.
    /// Only the protocol authority can create topics.
    pub fn create_topic(
        ctx: Context<CreateTopic>,
        name: String,
        description: String,
        commit_phase_duration: Option<u64>,
        reveal_phase_duration: Option<u64>,
    ) -> Result<()> {
        instructions::topics::create_topic(
            ctx,
            name,
            description,
            commit_phase_duration,
            reveal_phase_duration,
        )
    }

    /// Instruction handler: Submit data to a specific topic
    ///
    /// This creates a submission and links it to a topic, setting up the voting phases.
    pub fn submit_data_to_topic(
        ctx: Context<SubmitDataToTopic>,
        data_reference: String,
    ) -> Result<()> {
        instructions::submission::submit_data_to_topic(ctx, data_reference)
    }

    /// Instruction handler: Stake topic-specific temporary alignment tokens
    ///
    /// Burns tempAlign tokens from a specific topic and mints tempRep tokens for that topic
    pub fn stake_topic_specific_tokens(
        ctx: Context<StakeTopicSpecificTokens>,
        amount: u64,
    ) -> Result<()> {
        instructions::tokens::stake_topic_specific_tokens(ctx, amount)
    }

    // Removed legacy submit_data instruction - all submissions must be tied to a topic

    /// Instruction handler: Commit a vote on a submission within a topic
    ///
    /// This creates a vote commitment without revealing the actual vote choice.
    /// The actual vote is hashed with a nonce for privacy during the commit phase.
    pub fn commit_vote(
        ctx: Context<CommitVote>,
        vote_hash: [u8; 32],
        vote_amount: u64,
        is_permanent_rep: bool,
    ) -> Result<()> {
        instructions::votes::commit_vote(ctx, vote_hash, vote_amount, is_permanent_rep)
    }

    /// Instruction handler: Reveal a previously committed vote
    ///
    /// This reveals the actual vote choice and verifies it matches the previously committed hash.
    /// If valid, it adds the voter's voting power to the appropriate yes/no counter.
    pub fn reveal_vote(
        ctx: Context<RevealVote>,
        vote_choice: VoteChoice,
        nonce: String,
    ) -> Result<()> {
        instructions::votes::reveal_vote(ctx, vote_choice, nonce)
    }

    /// Instruction handler: Finalize a submission within a topic after voting
    ///
    /// This determines if a submission is accepted or rejected based on voting results.
    /// For accepted submissions, it converts contributor's tempAlign tokens to permanent Align tokens.
    pub fn finalize_submission(ctx: Context<FinalizeSubmission>) -> Result<()> {
        instructions::submission::finalize_submission(ctx)
    }

    /// Instruction handler: Finalize a validator's vote after submission has been finalized
    ///
    /// This processes the token rewards or penalties for a validator based on their vote:
    /// - For correct votes: Burn tempRep tokens and mint permanent Rep tokens
    /// - For incorrect votes: Just burn tempRep tokens with no replacement
    /// - No penalty for permanent Rep tokens used for voting
    pub fn finalize_vote(ctx: Context<FinalizeVote>) -> Result<()> {
        instructions::votes::finalize_vote(ctx)
    }

    /// Instruction handler: Link an existing submission to a topic
    ///
    /// This creates a new SubmissionTopicLink for an existing Submission and Topic,
    /// allowing the submission to be voted on in multiple topics independently.
    /// Anyone can link if they are willing to pay the transaction fee.
    pub fn link_submission_to_topic(ctx: Context<LinkSubmissionToTopic>) -> Result<()> {
        instructions::submission::link_submission_to_topic(ctx)
    }
    
    /// Instruction handler: Set voting phases for a submission-topic link
    ///
    /// This allows the protocol authority to manually set timestamps for the commit and reveal phases.
    /// This is primarily intended for testing and administrative purposes.
    pub fn set_voting_phases(
        ctx: Context<SetVotingPhases>,
        commit_phase_start: Option<u64>,
        commit_phase_end: Option<u64>,
        reveal_phase_start: Option<u64>,
        reveal_phase_end: Option<u64>,
    ) -> Result<()> {
        instructions::votes::set_voting_phases(ctx, commit_phase_start, commit_phase_end, reveal_phase_start, reveal_phase_end)
    }
}
