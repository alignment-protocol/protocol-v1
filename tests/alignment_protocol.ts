import * as anchor from "@coral-xyz/anchor";
import { Program } from "@coral-xyz/anchor";
import { AlignmentProtocol } from "../target/types/alignment_protocol"; 
// ^ This import gives us the TypeScript types for our program (auto-generated by Anchor after build).

import { PublicKey, SystemProgram, Keypair } from "@solana/web3.js";
import { TOKEN_PROGRAM_ID, getAccount, getMint } from "@solana/spl-token";
import { expect } from "chai";

describe("alignment_protocol", () => {
  // Configure the client to use the local cluster.
  const provider = anchor.AnchorProvider.env(); 
  anchor.setProvider(provider);
  const program = anchor.workspace.AlignmentProtocol as Program<AlignmentProtocol>;
  // ^ Anchor workspace automatically provides the program instance based on IDL and program ID.
  //   AlignmentProtocol is the type (IDL types) for our program, giving type hints for accounts/args.

  // Define some variables for the PDAs and signers we will use in tests.
  let statePda: PublicKey;
  let stateBump: number;
  let mintPda: PublicKey;
  let mintBump: number;
  const SEED_STATE = "state";
  const SEED_MINT = "mint";

  // We can also define an authority Keypair for testing (other than provider's wallet).
  const authority = Keypair.generate();

  it("Airdrops SOL to the authority (if using a custom authority)", async () => {
    // In case we use a separate authority keypair (not the provider), airdrop some SOL for fees.
    const sig = await provider.connection.requestAirdrop(authority.publicKey, 2 * 1e9); // 2 SOL
    await provider.connection.confirmTransaction(sig);
    // After this, our authority has SOL to pay for account creation.
  });

  it("Derives PDAs for state and mint", async () => {
    // The PDAs should match what the program expects (using same seeds and program ID).
    [statePda, stateBump] = await PublicKey.findProgramAddress(
      [Buffer.from(SEED_STATE)], // seed as bytes
      program.programId
    );
    [mintPda, mintBump] = await PublicKey.findProgramAddress(
      [Buffer.from(SEED_MINT)],
      program.programId
    );

    console.log("Derived state PDA:", statePda.toBase58(), "bump:", stateBump);
    console.log("Derived mint PDA:", mintPda.toBase58(), "bump:", mintBump);
  });

  it("Initializes the protocol state and mint", async () => {
    // Prepare the accounts for the initialize instruction.
    // If using provider.wallet as authority:
    // const authorityPubkey = provider.wallet.publicKey;
    // If using our custom authority Keypair:
    const authorityPubkey = authority.publicKey;

    // Call the initialize instruction.
    await program.methods
      .initialize()                              // no arguments in our initialize
      .accounts({
        state: statePda,
        mint: mintPda,
        authority: authorityPubkey,
        tokenProgram: TOKEN_PROGRAM_ID,         // Anchor constants for known program IDs
        systemProgram: SystemProgram.programId,
        rent: anchor.web3.SYSVAR_RENT_PUBKEY,
      })
      .signers([authority]) // The authority must sign. If authorityPubkey is provider.wallet, you can leave .signers([]) because provider signs automatically.
      .rpc();

    // The transaction succeeded if we got here (no error thrown).
    // Now let's fetch the accounts to verify initialization.

    // Fetch the state account data from the blockchain.
    const stateAccount = await program.account.state.fetch(statePda);
    // stateAccount is an object with the fields of our State struct.
    console.log("State account data:", stateAccount);

    // Check that the stored fields match expected values.
    expect(stateAccount.mint.toBase58()).to.equal(mintPda.toBase58());
    expect(stateAccount.authority.toBase58()).to.equal(authorityPubkey.toBase58());
    expect(stateAccount.bump).to.equal(stateBump);

    // Fetch the mint account data using SPL Token library to verify its authority.
    const mintInfo = await getMint(provider.connection, mintPda);
    // getMint comes from @solana/spl-token and returns mint details (decimals, supply, authorities, etc.)
    expect(mintInfo.decimals).to.equal(0); // we set 0 decimals
    expect(mintInfo.mintAuthority).to.not.be.null;
    if (mintInfo.mintAuthority) {
      expect(mintInfo.mintAuthority.toBase58()).to.equal(statePda.toBase58());
    }
    expect(mintInfo.freezeAuthority).to.not.be.null;
    if (mintInfo.freezeAuthority) {
      expect(mintInfo.freezeAuthority.toBase58()).to.equal(statePda.toBase58());
    }
    // We expect both mint authority and freeze authority to be our state PDA.

    console.log("Mint account authority:", mintInfo.mintAuthority?.toBase58());
  });
});
